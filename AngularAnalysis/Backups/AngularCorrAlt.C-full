//Connor Natzke
//July 28 2016
//
//This is an alternate macro to generate gg corr plots. It splits by angular index then by energy. 
//

#include <iostream>
#include <vector>
#include "AngularCorrAlt.H"
#include "TString.h"
#include "TMath.h"
#include "TGraphErrors.h"
#include "TLatex.h"

using namespace std;

AngularCorrAlt::AngularCorrAlt(){
	Double_t gateLow=948;	//First Gate
	Double_t gateHigh=950;	//First Gate
	Double_t ELow=1320;		//Low Energy Gate
	Double_t EHigh=1340;	//High Energy Gate
	Int_t angSplits=52;		//Number of Angular Indices
	TString isotope="^{44}P"; //Isotope

	TH3D *xyzProj=GetData();
	vector<TH1D*> histVec=AngCut(xyzProj,angSplits,gateLow, gateHigh);	
	vector<Double_t> rawcounts=FitHisto(histVec, angSplits, ELow, EHigh);
	vector<Double_t> errorFit=ErrorFits(histVec, angSplits, ELow, EHigh);
	//Only use if you are using the full GRIFFIN Detector array, weights are specific
	vector<Double_t> wcounts=WeightAdjust(rawcounts,angSplits);
	vector<Double_t> countsError=ErrorAdjust(errorFit,angSplits);
	vector<Double_t> errorAlt=AltError(rawcounts,angSplits);
	AngularCorrHisto(wcounts,isotope,errorAlt);
}

//**********************************************************************************
//Generates a 3D histogram from the Converted.root file and the THnSparse
//**********************************************************************************
TH3D* AngularCorrAlt::GetData(){
  
	TFile* isoData = new TFile("/home/cnatzke/Griffin_Sim_v10/detectorSimulations_v10-build/Simulation_Results/Converted.root");
	isoData->cd("GriffinND");
	THnSparse * dataFull=(THnSparse*) gDirectory->Get("griffin_crystal_unsup_gamma_gamma_corr_edep_cry_addback_sparse");
	TH3D * xyzProj=(TH3D*) dataFull->Projection(0,1,2);	//3D Histogram

	return xyzProj;
}

//**********************************************************************************
//Cuts the 3D Histogram at each angular index and projects/plots a histogram for each index
//**********************************************************************************
vector<TH1D*> AngularCorrAlt::AngCut(TH3D* xyzProj, Int_t angSplits,Double_t gateLow, Double_t gateHigh){

	vector<TH1D*> histVec(angSplits); //Initialize Vector of Histograms

	c1=TCanvas("c1","c1",600,600);
	gStyle->SetOptStat(10);
	c1.SetLogy();

	for(Int_t i=0;i<angSplits;i++){ //loop through angular indices

		Double_t indLow=i; //Starts at bin0
		Double_t indHigh=indLow+1; //cut at 1 bin higher

       //histogram titles
		TString h_title("Angular Histogram for Index ");
		h_title+=indLow;
		h_title+=";Energy (keV);Index ";
		h_title+=indLow;
		cout << h_title.Data() << endl;

       //Projection titles
		TString p_title("Projection Histogram for Index ");
		p_title+=indLow;
		p_title+=";Energy (keV);Counts";
		cout << p_title.Data() << endl;
		
	   //Histogram Names
		TString h_name("h_angIndex_");
		h_name+=i;
		cout << h_name.Data() << endl;
		

		delete histVec[i]; //clear memory space
		xyzProj->GetZaxis()->SetRangeUser(indLow,indHigh);		//First Cut
		TH2D * ggProj=(TH2D*) xyzProj->Project3D("xy");
		ggProj->GetXaxis()->SetRangeUser(gateLow,gateHigh);			//Second Cut
		histVec[i]=ggProj->ProjectionY(h_name,gateLow,gateHigh,"e");
		histVec[i]->SetTitle(p_title);
		histVec[i]->SetMinimum(1.0);							//Set y axis minimum
		histVec[i]->SetMaximum(2000);							//Set y axis maximum
		histVec[i]->Draw();

		//Save Histogram
		c1.Update();
		TString path("/home/cnatzke/Griffin_Sim_v10/detectorSimulations_v10-build/Simulation_Results/Angular_Histograms/NonFitted/");
		path+=h_name;
		path+=".png";
		cout << path.Data() << endl;
		c1.SaveAs(path);
	}
	return histVec;
}

//**********************************************************************************
//Takes in vector of histograms,fits a gaussian to the photopeak of interest, integrates fit to find counts, returns counts
//**********************************************************************************
vector<Double_t> AngularCorrAlt::FitHisto(vector<TH1D*> histVec,Int_t angSplits, Double_t ELow,Double_t EHigh){
	
	c1=TCanvas("c1","c1",600,600);
	gStyle->SetOptStat(10);
	c1.SetLogy();
	
	//Describing the Fit
	TF1 * gFit=new TF1("gFit","gaus",ELow, EHigh);
	vector<Double_t> counts(angSplits); //Initalize Vector for Counts


	for(Int_t i=0;i<angSplits;i++){ 
		histVec[i]->GetXaxis()->SetRangeUser(ELow-5,EHigh+5);	//Setting Range of Histogram to allow data fitting
		histVec[i]->SetMinimum(1.0);							//Set y-axis minimum
		histVec[i]->SetMaximum(2000);							//Set y-axis maximum
		histVec[i]->Fit("gFit","Q");							//Fitting
		counts[i]=gFit->Integral(ELow,EHigh);					//Integrating Peak to Find Counts
//		histVec[i]->GetXaxis()->SetRangeUser(0,2500);			//Resetting Range for Cosmetic Purposes
		histVec[i]->Draw();
		gFit->Draw("SAME");

	   //Histogram Names
		TString h_name("h_angIndex_");
		h_name+=i;
		h_name+="_fitted";
		cout << h_name.Data() << endl;

		//Save Histogram
		c1.Update();
		TString path("/home/cnatzke/Griffin_Sim_v10/detectorSimulations_v10-build/Simulation_Results/Angular_Histograms/Fitted/");
		path+=h_name;
		path+=".png";
		cout << path.Data() << endl;
		c1.SaveAs(path);
		
	}
	return counts;
}
//**********************************************************************************
//Calculates errors from histogram fit and integral for error bars on the final correlation plot
//**********************************************************************************
vector<Double_t> AngularCorrAlt::ErrorFits(vector<TH1D*> histVec,Int_t angSplits, Double_t ELow,Double_t EHigh){
	
	c1=TCanvas("c1","c1",600,600);
	gStyle->SetOptStat(10);
	c1.SetLogy();
	
	//Describing the Fit
	TF1 * gFit=new TF1("gFit","gaus",ELow, EHigh);
	vector<Double_t> countsError(angSplits); //Initalize Vector for Counts


	for(Int_t i=0;i<angSplits;i++){ 
		histVec[i]->GetXaxis()->SetRangeUser(ELow-5,EHigh+5);	//Setting Range of Histogram to allow data fitting
		histVec[i]->SetMinimum(1.0);							//Set y-axis minimum
		histVec[i]->SetMaximum(20000);							//Set y-axis maximum
		histVec[i]->Fit("gFit","Q");							//Fitting
		countsError[i]=gFit->IntegralError(ELow,EHigh);			//Finds Error in Counts
//		histVec[i]->GetXaxis()->SetRangeUser(0,2500);			//Resetting Range for Cosmetic Purposes
		histVec[i]->Draw();
		gFit->Draw("SAME");

		
		cout << countsError[i] << " ";
	}
	cout << endl;
	return countsError;
}
//**********************************************************************************
//Normalizes the counts for the photopeak
//**********************************************************************************
vector<Double_t> AngularCorrAlt::WeightAdjust(vector<Double_t> counts, Int_t angSplits){

	vector<Double_t> wcounts(angSplits);

	for(Int_t i=0;i<angSplits;i++){
		if(i==1||i==6||i==8||i==25||i==26||i==43||i==45||i==50){
				wcounts[i]=counts[i]/(128);
		}
		else if(i==5||i==10||i==12||i==24||i==27||i==39||i==41||i==46){
				wcounts[i]=counts[i]/(48);
		}
		else if(i==7||i==9||i==11||i==14||i==18||i==20||i==31||i==33||i==37||i==40||i==42||i==44){
				wcounts[i]=counts[i]/(96);
		}
		else{
				wcounts[i]=counts[i]/(64);
		}
//		cout << wcounts[i] << " ";
	}
//	cout << endl;
	return wcounts;
}
//**********************************************************************************
//Alternate Error Calculation
//**********************************************************************************
vector<Double_t> AngularCorrAlt::AltError(vector<Double_t> counts, Int_t angSplits){

	vector<Double_t> errorAlt(angSplits);

	for(Int_t i=0;i<angSplits;i++){
		if(i==1||i==6||i==8||i==25||i==26||i==43||i==45||i==50){
				errorAlt[i]=TMath::Sqrt(counts[i])/(128);
		}
		else if(i==5||i==10||i==12||i==24||i==27||i==39||i==41||i==46){
				errorAlt[i]=TMath::Sqrt(counts[i])/(48);
		}
		else if(i==7||i==9||i==11||i==14||i==18||i==20||i==31||i==33||i==37||i==40||i==42||i==44){
				errorAlt[i]=TMath::Sqrt(counts[i])/(96);
		}
		else{
				errorAlt[i]=TMath::Sqrt(counts[i])/(64);
		}
//		cout << wcounts[i] << " ";
	}
//	cout << endl;
	return errorAlt;
}
//**********************************************************************************
//Normalizes Errors
//**********************************************************************************
vector<Double_t> AngularCorrAlt::ErrorAdjust(vector<Double_t> errorfit, Int_t angSplits){

	vector<Double_t> wcountsError(angSplits);

	for(Int_t i=0;i<angSplits;i++){
		if(i==1||i==6||i==8||i==25||i==26||i==43||i==45||i==50){
				wcountsError[i]=errorfit[i]/(128);
		}
		else if(i==5||i==10||i==12||i==24||i==27||i==39||i==41||i==46){
				wcountsError[i]=errorfit[i]/(48);
		}
		else if(i==7||i==9||i==11||i==14||i==18||i==20||i==31||i==33||i==37||i==40||i==42||i==44){
				wcountsError[i]=errorfit[i]/(96);
		}
		else{
				wcountsError[i]=errorfit[i]/(64);
		}
//		cout << wcountsError[i] << " ";
	}
//	cout << endl;
	return wcountsError;
}
//**********************************************************************************
//Plots Counts vs Angles
//**********************************************************************************
void AngularCorrAlt::AngularCorrHisto(vector<Double_t> wcounts, TString isotope,vector<Double_t> countErrors){
	//Angular Indices
	Double_t index[]={0.0,18.79097,25.60153, 26.69036,31.94623,33.65414, 44.36426, 46.79372, 48.57554, 49.79788, 53.83362, 60.15106, 62.70487, 63.08604, 65.01569, 66.46082, 67.45617, 69.86404, 70.86009, 73.08384, 76.38138, 78.66898, 83.04252, 86.22840, 86.23761, 88.47356, 91.52644, 93.76239, 93.77160, 96.95749, 101.33102, 103.61822, 106.91616, 109.13991, 110.13596, 112.54383, 113.53918, 114.98431, 116.91396, 117.29513, 119.84894, 126.16638, 130.20212, 131.42446, 133.20628, 135.63574, 146.34586, 148.05377, 153.30964, 154.39847, 161.21315,180.0};

	vector<Double_t> indexVec(52);
	vector<Double_t> errorCounts(52); //Initalize Vector for Counts
	vector<Double_t> indexErrors(52); //Initalize Vector for Counts

	for(Int_t i=0;i<52;i++){
		indexVec[i]=TMath::Cos(index[i]*TMath::Pi()/(180));
		errorCounts[i]=TMath::Sqrt(wcounts[i]);
		indexErrors[i]=0;
	}

	TCanvas * c1=new TCanvas("c1","c1",600,600);

	TGraphErrors * g=new TGraphErrors(52,&indexVec[0],&wcounts[0],&indexErrors[0],&countErrors[0]);

	//Plot name
		TString c_name("Angular Correlation for ");
		c_name+=isotope;
		c_name+=";Cos(#theta);Normalized Counts";
		cout << c_name.Data() << endl;

	g->SetTitle(c_name);
	g->SetMarkerStyle(7);
	g->GetXaxis()->CenterTitle();
	g->GetYaxis()->CenterTitle();
	g->Draw("AP");


	   //Save Histogram
		c1->Update();
		TString path("/home/cnatzke/Griffin_Sim_v10/detectorSimulations_v10-build/Simulation_Results/");
		path+="corr";
		path+=".pdf";
		cout << path.Data() << endl;
		c1->SaveAs(path);
}
